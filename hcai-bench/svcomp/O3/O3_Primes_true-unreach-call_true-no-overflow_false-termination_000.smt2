(set-logic HORN)


(declare-fun |main@tailrecurse.i.i.i| ( Int Int Int Int Int ) Bool)
(declare-fun |main@entry| ( ) Bool)
(declare-fun |mult@tailrecurse| ( Int Int Int ) Bool)
(declare-fun |main@is_prime.exit.split| ( ) Bool)
(declare-fun |mult@_br| ( Int Int ) Bool)
(declare-fun |mult@UnifiedReturnBlock.split| ( Int Int Int ) Bool)
(declare-fun |main@tailrecurse.outer.i.i.i| ( Int Int Int Int Int ) Bool)
(declare-fun |mult| ( Bool Bool Bool Int Int Int ) Bool)
(declare-fun |main@tailrecurse.outer.i.i.preheader.i| ( Int Int ) Bool)

(assert
  (forall ( (A Int) (B Int) (C Int) (v_3 Bool) (v_4 Bool) (v_5 Bool) ) 
    (=>
      (and
        (and true (= v_3 true) (= v_4 true) (= v_5 true))
      )
      (mult v_3 v_4 v_5 A B C)
    )
  )
)
(assert
  (forall ( (A Int) (B Int) (C Int) (v_3 Bool) (v_4 Bool) (v_5 Bool) ) 
    (=>
      (and
        (and true (= v_3 false) (= v_4 true) (= v_5 true))
      )
      (mult v_3 v_4 v_5 A B C)
    )
  )
)
(assert
  (forall ( (A Int) (B Int) (C Int) (v_3 Bool) (v_4 Bool) (v_5 Bool) ) 
    (=>
      (and
        (and true (= v_3 false) (= v_4 false) (= v_5 false))
      )
      (mult v_3 v_4 v_5 A B C)
    )
  )
)
(assert
  (forall ( (A Int) (B Int) (C Int) (v_3 Bool) (v_4 Bool) (v_5 Bool) ) 
    (=>
      (and
        (mult@UnifiedReturnBlock.split C A B)
        (and (= v_3 true) (= v_4 false) (= v_5 false))
      )
      (mult v_3 v_4 v_5 A B C)
    )
  )
)
(assert
  (forall ( (A Int) (B Int) ) 
    (=>
      (and
        true
      )
      (mult@_br A B)
    )
  )
)
(assert
  (forall ( (A Bool) (B Bool) (C Int) (D Int) (E Int) (F Int) ) 
    (=>
      (and
        (mult@_br D F)
        (and (or (not B) (not A) (= E C))
     (or (not A) (and B A))
     (= A true)
     (or (not B) (not A) (= C F)))
      )
      (mult@tailrecurse D E F)
    )
  )
)
(assert
  (forall ( (A Int) (B Bool) (C Int) (D Bool) (E Bool) (F Int) (G Int) (H Int) (I Int) ) 
    (=>
      (and
        (mult@tailrecurse G A I)
        (and (= C (* (- 1) A))
     (or (not E) (not D) (= F C))
     (or (not E) (not D) (= H F))
     (or (not E) (not D) B)
     (or (not D) (and E D))
     (= D true)
     (not (= (<= 0 A) B)))
      )
      (mult@tailrecurse G H I)
    )
  )
)
(assert
  (forall ( (A Int) (B Bool) (C Int) (D Bool) (E Int) (F Int) (G Int) (H Int) (I Bool) (J Bool) (K Bool) (L Bool) (M Int) (N Bool) (O Bool) (P Int) (Q Int) (R Int) (S Bool) (T Int) (U Bool) (V Int) (W Bool) (X Bool) (Y Int) (Z Int) (A1 Int) (v_27 Bool) (v_28 Bool) ) 
    (=>
      (and
        (mult@tailrecurse Z C A1)
        (mult U v_27 v_28 Z G H)
        (let ((a!1 (or (not N) (not (= (<= 1 F) J)))))
  (and (= v_27 false)
       (= v_28 false)
       (= A (* (- 1) C))
       (or (not L) (not K) (= M 1))
       (or (not L) (not K) (= Q M))
       (or (not L) (not K) I)
       (or (not N) (not D) (= E C))
       (or (not N) (not D) (= F E))
       (or (not N) (not D) (not B))
       (or (not N) (not K) (not J))
       (or (not O) (not N) (= P 0))
       (or (not O) (not N) (= Q P))
       (or (not O) (not N) J)
       (or (not S) (and O N) (and L K))
       (or (not U) (not K) (not I))
       (or (not W) (and W U) (and W S))
       (or (not W) (not S) (= T Q))
       (or (not W) (not S) (= Y T))
       (or (not W) (not U) (= V R))
       (or (not W) (not U) (= Y V))
       (or (not K) (= I (= F 1)))
       (or (not K) (and N K))
       (or (not L) K)
       a!1
       (or (not N) (and N D))
       (or (not O) N)
       (or (not U) (= G (+ (- 1) F)))
       (or (not U) (= R (+ H Z)))
       (or (not U) (and U K))
       (or (not X) (and W X))
       (= X true)
       (not (= (<= 0 C) B))))
      )
      (mult@UnifiedReturnBlock.split Y Z A1)
    )
  )
)
(assert
  (forall ( (CHC_COMP_UNUSED Bool) ) 
    (=>
      (and
        true
      )
      main@entry
    )
  )
)
(assert
  (forall ( (A Int) (B Bool) (C Bool) (D Bool) (E Bool) (F Bool) (G Bool) (H Bool) (I Int) (J Int) (K Int) ) 
    (=>
      (and
        main@entry
        (let ((a!1 (= B (or (not (<= A 46339)) (not (>= A 0))))))
  (and a!1
       (= A (+ (- 1) J))
       (or (not C) (not D) (not E))
       (or (not H) (not F) (not E))
       (or (not H) (not G) (= I J))
       (or (not H) (not G) (= K I))
       (or (not E) (= F (= J 2)))
       (or (not E) (and E C))
       (or (not H) (and H E))
       (or (not G) (and G H))
       (not B)
       (= G true)
       (not (= (<= 2 J) D))))
      )
      (main@tailrecurse.outer.i.i.preheader.i J K)
    )
  )
)
(assert
  (forall ( (A Int) (B Bool) (C Int) (D Bool) (E Int) (F Bool) (G Bool) (H Int) (I Bool) (J Bool) (K Int) (L Bool) (M Bool) (N Int) (O Bool) (P Int) (Q Bool) (R Bool) (S Int) (T Int) (U Int) ) 
    (=>
      (and
        (main@tailrecurse.i.i.i T K N P C)
        (let ((a!1 (or (not F) (not (= (<= 0 K) G))))
      (a!2 (or (not R) (not (= (<= 4 N) O)))))
  (and (= A (* (- 1) C))
       (or (not F) (not D) (= H E))
       (or (not F) (not D) (= E C))
       (or (not F) (not D) (not B))
       (or (not I) (not F) (not G))
       (or (not I) (not L) (not J))
       (or (not R) (not L) M)
       (or (not R) (not Q) (= S P))
       (or (not R) (not Q) (= U S))
       (or (not R) (not Q) (not O))
       a!1
       (or (not F) (and F D))
       (or (not I) (= J (= H 0)))
       (or (not I) (and I F))
       a!2
       (or (not R) (and L R))
       (or (not L) (= M (= K 0)))
       (or (not L) (and L I))
       (or (not Q) (and Q R))
       (= Q true)
       (not (= (<= 0 C) B))))
      )
      (main@tailrecurse.outer.i.i.preheader.i T U)
    )
  )
)
(assert
  (forall ( (A Int) (B Bool) (C Bool) (D Bool) (E Bool) (F Bool) (G Bool) (H Bool) (I Bool) (J Bool) (K Int) (L Bool) (M Int) (N Bool) (O Bool) (P Bool) (Q Int) (R Int) (S Int) (T Bool) (U Bool) (V Int) (W Bool) (X Bool) (Y Bool) (Z Bool) (A1 Bool) (v_27 Bool) (v_28 Bool) ) 
    (=>
      (and
        main@entry
        (mult Z v_27 v_28 S V Q)
        (let ((a!1 (= B (or (not (<= A 46339)) (not (>= A 0)))))
      (a!2 (or (not Z) (not (= (<= V 1) W))))
      (a!3 (or (not Z) (not (= (<= S 1) T))))
      (a!4 (= L (or (not (<= K 46339)) (not (>= K 0)))))
      (a!5 (= O (and (not (<= 46340 M)) (>= M 0)))))
  (and (= v_27 false)
       (= v_28 false)
       a!1
       (= A (+ (- 1) R))
       (or (not F) (not E) (= N G))
       (or (not F) (not E) C)
       (or G (not E) (not F))
       (or (not Z) (and I H) (and F E))
       (or (not D) (not H) (not E))
       (or (not I) (not H) (= N J))
       (or (not I) D (not H))
       (or (not J) (not I) (not H))
       (or (not E) (= C (= R 2)))
       (or (not E) (and H E))
       (or (not F) E)
       a!2
       a!3
       (or (not Z) (= P (and O N)))
       (or (not Z) (= Y (and W X)))
       (or (not Z) a!4)
       (or (not Z) a!5)
       (or (not Z) (= U (= Q R)))
       (or (not Z) (= X (and T U)))
       (or (not Z) (= K (+ (- 1) S)))
       (or (not Z) (= M (+ (- 1) V)))
       (or (not Z) P)
       (or (not Z) Y)
       (or (not A1) (and A1 Z))
       (or (not I) H)
       (or (not L) (not Z))
       (= A1 true)
       (not B)
       (not (= (<= 2 R) D))))
      )
      main@is_prime.exit.split
    )
  )
)
(assert
  (forall ( (A Int) (B Int) (C Bool) (D Int) (E Bool) (F Int) (G Bool) (H Bool) (I Int) (J Int) (K Bool) (L Bool) (M Int) (N Bool) (O Bool) (P Bool) (Q Bool) (R Bool) (S Bool) (T Bool) (U Bool) (V Int) (W Bool) (X Int) (Y Bool) (Z Bool) (A1 Bool) (B1 Int) (C1 Int) (D1 Int) (E1 Bool) (F1 Bool) (G1 Int) (H1 Bool) (I1 Bool) (J1 Bool) (K1 Bool) (L1 Bool) (v_38 Bool) (v_39 Bool) ) 
    (=>
      (and
        (main@tailrecurse.i.i.i C1 J M A D)
        (mult K1 v_38 v_39 D1 G1 B1)
        (let ((a!1 (or (not G) (not (= (<= 0 J) H))))
      (a!2 (or (not N) (not (= (<= 4 M) O))))
      (a!3 (or (not K1) (not (= (<= G1 1) H1))))
      (a!4 (or (not K1) (not (= (<= D1 1) E1))))
      (a!5 (= W (or (not (<= V 46339)) (not (>= V 0)))))
      (a!6 (= Z (and (not (<= 46340 X)) (>= X 0)))))
  (and (= v_38 false)
       (= v_39 false)
       (= B (* (- 1) D))
       (or (not G) (not E) (= F D))
       (or (not G) (not E) (= I F))
       (or (not G) (not E) (not C))
       (or (not N) (not K) L)
       (or (not P) (not H) (not G))
       (or (not Q) (not P) (not K))
       (or (and K1 R) (not K1) (and T K1))
       (or (not K1) (not R) (= Y S))
       (or S (not R) (not K1))
       (or O (not R) (not N))
       (or (not T) Q (not P))
       (or (not T) (= Y U) (not K1))
       (or (not T) (not U) (not K1))
       a!1
       (or (not G) (and G E))
       (or (not K) (= L (= J 0)))
       (or (not K) (and P K))
       a!2
       (or (not N) (and N K))
       (or (not P) (= Q (= I 0)))
       (or (not P) (and P G))
       (or (not R) (and R N))
       a!3
       a!4
       (or (not K1) (= A1 (and Z Y)))
       (or (not K1) (= J1 (and H1 I1)))
       (or (not K1) a!5)
       (or (not K1) a!6)
       (or (not K1) (= F1 (= B1 C1)))
       (or (not K1) (= I1 (and E1 F1)))
       (or (not K1) (= V (+ (- 1) D1)))
       (or (not K1) (= X (+ (- 1) G1)))
       (or (not K1) A1)
       (or (not K1) J1)
       (or (not L1) (and L1 K1))
       (or (not T) (and T P))
       (or (not W) (not K1))
       (= L1 true)
       (not (= (<= 0 D) C))))
      )
      main@is_prime.exit.split
    )
  )
)
(assert
  (forall ( (A Int) (B Bool) (C Bool) (D Int) (E Int) (F Int) (G Int) (H Int) (I Int) ) 
    (=>
      (and
        (main@tailrecurse.outer.i.i.preheader.i E H)
        (and (or (not B) (= D I) (not C))
     (or (not B) (= A E) (not C))
     (or (not B) (= F A) (not C))
     (or (not B) (= G D) (not C))
     (or (not B) (and B C))
     (= B true)
     (= I (+ (- 1) H)))
      )
      (main@tailrecurse.outer.i.i.i E F G H I)
    )
  )
)
(assert
  (forall ( (A Int) (B Bool) (C Int) (D Bool) (E Int) (F Bool) (G Bool) (H Bool) (I Bool) (J Bool) (K Bool) (L Int) (M Int) (N Int) (O Bool) (P Int) (Q Bool) (R Int) (S Int) (T Int) (U Int) (V Bool) (W Bool) (X Int) (Y Int) (Z Int) (A1 Int) (B1 Int) (C1 Int) ) 
    (=>
      (and
        (main@tailrecurse.i.i.i Y L B1 C1 C)
        (let ((a!1 (or (not O) (= M (+ L (* (- 1) T)))))
      (a!2 (or (not J) (not (= (<= 0 L) K)))))
  (and (= A (* (- 1) C))
       (or (not O) (not I) (not H))
       (or (not D) (not J) (= E C))
       (or (not D) (not J) (= T E))
       (or (not D) (not J) (not B))
       (or (not F) (not G) (not H))
       (or (not K) (not F) (not J))
       (or (not Q) K (not J))
       (or (not W) (and W Q) (and W O))
       (or (not W) (not O) (= P M))
       (or (not W) (not O) (= S P))
       (or (not W) (not Q) (= R N))
       (or (not W) (not Q) (= S R))
       (or (not V) (= X T) (not W))
       (or (not V) (not W) (= U S))
       (or (not V) (= Z U) (not W))
       (or (not V) (= A1 X) (not W))
       a!1
       (or (not O) (and H O))
       (or (not H) (= I (= L 0)))
       (or (not H) (and F H))
       a!2
       (or (not J) (and D J))
       (or (not F) (= G (= T 0)))
       (or (not F) (and F J))
       (or (not Q) (= N (* (- 1) L)))
       (or (not Q) (and Q J))
       (or (not V) (and V W))
       (= V true)
       (not (= (<= 0 C) B))))
      )
      (main@tailrecurse.outer.i.i.i Y Z A1 B1 C1)
    )
  )
)
(assert
  (forall ( (A Int) (B Bool) (C Bool) (D Int) (E Int) (F Int) (G Int) (H Int) (I Int) ) 
    (=>
      (and
        (main@tailrecurse.outer.i.i.i E F A G H)
        (and (or (= I D) (not B) (not C))
     (or (not B) (and B C))
     (= B true)
     (or (= D A) (not B) (not C)))
      )
      (main@tailrecurse.i.i.i E F G H I)
    )
  )
)
(assert
  (forall ( (A Int) (B Bool) (C Int) (D Bool) (E Bool) (F Int) (G Int) (H Int) (I Int) (J Int) (K Int) ) 
    (=>
      (and
        (main@tailrecurse.i.i.i G H I J A)
        (and (= C (* (- 1) A))
     (or (= F C) (not D) (not E))
     (or (= K F) (not D) (not E))
     (or (not D) B (not E))
     (or (not D) (and D E))
     (= D true)
     (not (= (<= 0 A) B)))
      )
      (main@tailrecurse.i.i.i G H I J K)
    )
  )
)
(assert
  (forall ( (CHC_COMP_UNUSED Bool) ) 
    (=>
      (and
        main@is_prime.exit.split
        true
      )
      false
    )
  )
)

(check-sat)
(exit)
