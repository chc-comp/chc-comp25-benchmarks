(set-logic HORN)


(declare-fun |main@entry| ( Int ) Bool)
(declare-fun |main@__VERIFIER_assert.split| ( ) Bool)
(declare-fun |main@.lr.ph| ( Int Int Int Int Int ) Bool)

(assert
  (forall ( (A Int) ) 
    (=>
      (and
        true
      )
      (main@entry A)
    )
  )
)
(assert
  (forall ( (A Int) (B Bool) (C Bool) (D Int) (E Int) (F Bool) (G Bool) (H Int) (I Int) (J Int) (K Int) (L Int) (M Int) ) 
    (=>
      (and
        (main@entry M)
        (and (= A M)
     (or (not G) C (not B))
     (or (not G) (not F) (= D 0))
     (or (not G) (not F) (= E 0))
     (or (not G) (not F) (= H 0))
     (or (not G) (not F) (= I D))
     (or (not G) (not F) (= K E))
     (or (not G) (not F) (= L H))
     (or (not F) (and G F))
     (or (not G) (and G B))
     (= C true)
     (= F true)
     (not (= (<= J 0) C)))
      )
      (main@.lr.ph I J K L M)
    )
  )
)
(assert
  (forall ( (A Int) (B Bool) (C Bool) (D Bool) (E Bool) (F Int) (G Bool) (H Int) (I Int) (J Int) (K Int) (L Bool) (M Bool) (N Bool) (O Bool) (P Int) (Q Bool) (R Int) (S Int) (T Int) (U Int) (V Int) (W Bool) (X Bool) (Y Int) (Z Int) (A1 Int) (B1 Int) (C1 Int) (D1 Int) ) 
    (=>
      (and
        (main@.lr.ph P A1 H I D1)
        (let ((a!1 (or (not L) (not (= (= S 0) N))))
      (a!2 (or (not L) (= J (+ H (* (- 1) I)))))
      (a!3 (or (not X) (not (= (<= A1 R) Q)))))
  (and (= A (ite D 1 0))
       (or (not L) (not B) C)
       (or (not X) (not L) M)
       (or (not X) (not W) (= U R))
       (or (not X) (not W) (= V S))
       (or (not X) (not W) (= Y T))
       (or (not X) (not W) (= Z U))
       (or (not X) (not W) (= B1 V))
       (or (not X) (not W) (= C1 Y))
       (or (not X) (not W) Q)
       a!1
       (or (not L) (not (= D E)))
       (or (not L) (= G (= T 0)))
       (or (not L) (= F D1))
       a!2
       (or (not L) (= K (ite N 1 0)))
       (or (not L) (= S (+ T J)))
       (or (not L) (and L B))
       (or (not L) (not E))
       (or (not L) (not G))
       (or (not W) (and X W))
       a!3
       (or (not X) (not (= N O)))
       (or (not X) (= R (+ 1 P)))
       (or (not X) (and X L))
       (or (not X) (not O))
       (= W true)
       (= D (= H I))))
      )
      (main@.lr.ph Z A1 B1 C1 D1)
    )
  )
)
(assert
  (forall ( (A Int) (B Int) (C Int) (D Bool) (E Bool) (F Bool) (G Bool) (H Bool) (I Int) (J Bool) (K Int) (L Int) (M Bool) (N Bool) (O Bool) ) 
    (=>
      (and
        (main@entry B)
        (and (= A B)
     (or (not N) (not J) (= K I))
     (or (not N) (not J) (= L K))
     (or (= G F) (not J) (not E))
     (or F (not J) (not E))
     (or (not D) (not J) (not E))
     (or (not J) (= I (ite G 1 0)))
     (or (not J) (and E J))
     (or (not N) (= M (= L 0)))
     (or (not N) (and N J))
     (or (not N) M)
     (or (not O) (and O N))
     (or (not H) (not J))
     (= O true)
     (= D true)
     (not (= (<= C 0) D)))
      )
      main@__VERIFIER_assert.split
    )
  )
)
(assert
  (forall ( (A Bool) (B Bool) (C Int) (D Int) (E Bool) (F Int) (G Int) (H Int) (I Int) (J Int) (K Bool) (L Int) (M Bool) (N Int) (O Bool) (P Bool) (Q Int) (R Bool) (S Bool) (T Bool) (U Bool) (V Int) (W Int) (X Int) (Y Bool) (Z Int) (A1 Bool) (B1 Int) (C1 Int) (D1 Bool) (E1 Bool) (F1 Bool) (G1 Bool) (H1 Bool) (I1 Int) (J1 Int) (K1 Bool) (L1 Int) (M1 Bool) (N1 Int) (O1 Int) (P1 Bool) (Q1 Bool) (R1 Bool) ) 
    (=>
      (and
        (main@.lr.ph V X F G D)
        (let ((a!1 (or (not R) (not (= (= Z 0) T))))
      (a!2 (or (not R) (= I (+ F (* (- 1) G)))))
      (a!3 (or (not A1) (not (= (<= X W) Y)))))
  (and (= L (ite A 1 0))
       (or (not P) (not O) (= Q L))
       (or (not P) (not O) (= I1 Q))
       (or (not P) (not O) (not K))
       (or (not R) (not M) (= N J))
       (or (not R) (not M) (= I1 N))
       (or (not R) (not O) K)
       (or (not S) (not R) (not M))
       (or S (not A1) (not R))
       (or (not E1) (not A1) (= B1 Z))
       (or (not E1) (not A1) (= C1 B1))
       (or (not E1) (not A1) (not Y))
       (or (not M1) (not E1) (= F1 D1))
       (or (not M1) (not E1) (= G1 F1))
       (or (and Q1 M1) (not Q1) (and K1 Q1))
       (or (not Q1) (not M1) (= N1 J1))
       (or (not Q1) (not M1) (= O1 N1))
       (or (not K1) (and R M) (and P O))
       (or (not K1) (not Q1) (= L1 I1))
       (or (not K1) (not Q1) (= O1 L1))
       (or (not P) O)
       a!1
       (or (not R) (not (= A B)))
       (or (not R) (= E (= H 0)))
       (or (not R) (= C D))
       a!2
       (or (not R) (= J (ite T 1 0)))
       (or (not R) (= Z (+ H I)))
       (or (not R) (and R O))
       (or (not R) (not B))
       (or (not R) (not E))
       (or R (not M))
       a!3
       (or (not A1) (not (= T U)))
       (or (not A1) (= W (+ 1 V)))
       (or (not A1) (and A1 R))
       (or (not A1) (not U))
       (or (not E1) (= D1 (= C1 0)))
       (or (not E1) (and E1 A1))
       (or (not M1) (= J1 (ite G1 1 0)))
       (or (not M1) (and M1 E1))
       (or (not Q1) (= P1 (= O1 0)))
       (or (not Q1) P1)
       (or (not R1) (and R1 Q1))
       (or (not M1) (not H1))
       (= R1 true)
       (= A (= F G))))
      )
      main@__VERIFIER_assert.split
    )
  )
)
(assert
  (forall ( (CHC_COMP_UNUSED Bool) ) 
    (=>
      (and
        main@__VERIFIER_assert.split
        true
      )
      false
    )
  )
)

(check-sat)
(exit)
